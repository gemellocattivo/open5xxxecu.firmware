<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>O5E: Tuner_OPS.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    </ul>
  </div>
<h1>Tuner_OPS.c</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/**********************************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment"></span>
<a name="l00003"></a>00003 <span class="comment">@file   Tuner_OPS.c </span>
<a name="l00004"></a>00004 <span class="comment">@author Jon Zeeff </span>
<a name="l00005"></a>00005 <span class="comment">@date   October, 2011</span>
<a name="l00006"></a>00006 <span class="comment">@brief  Open5xxxECU - handles communications with a tuner</span>
<a name="l00007"></a>00007 <span class="comment">@version 1.0</span>
<a name="l00008"></a>00008 <span class="comment">@copyright MIT License</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment">**********************************************************************************/</span>
<a name="l00011"></a>00011 <span class="comment">/*</span>
<a name="l00012"></a>00012 <span class="comment">Copyright (c) 2011 Jon Zeeff</span>
<a name="l00013"></a>00013 <span class="comment"></span>
<a name="l00014"></a>00014 <span class="comment">Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</span>
<a name="l00015"></a>00015 <span class="comment"></span>
<a name="l00016"></a>00016 <span class="comment">The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</span>
<a name="l00017"></a>00017 <span class="comment"></span>
<a name="l00018"></a>00018 <span class="comment">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span>
<a name="l00019"></a>00019 <span class="comment"></span>
<a name="l00020"></a>00020 <span class="comment">*/</span>
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;config.h&quot;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;main.h&quot;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#define EXTERN</span>
<a name="l00026"></a>00026 <span class="preprocessor"></span><span class="preprocessor">#include &quot;Tuner_OPS.h&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;Packet.h&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;Serial.h&quot;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;eSCI_DMA.h&quot;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;Flash_OPS.h&quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;OS.h&quot;</span>
<a name="l00032"></a>00032 
<a name="l00033"></a>00033 <span class="keyword">static</span> uint8_t tmp_buf[SERIAL_BUFFER_SIZE];     <span class="comment">// just to hold it while we process it</span>
<a name="l00034"></a>00034 <span class="keyword">static</span> uint8_t stream[MAX_PACKET_SIZE];     <span class="comment">// buffer ready for serial output</span>
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 <span class="comment">// this task runs continuously, reads from serial port, interprets packets, sends response</span>
<a name="l00037"></a>00037 
<a name="l00038"></a>00038 <span class="keywordtype">void</span> tuner_task(<span class="keywordtype">void</span>)
<a name="l00039"></a>00039 {
<a name="l00040"></a>00040         <span class="keyword">static</span> int32_t i;
<a name="l00041"></a>00041         <span class="keyword">static</span> int32_t count;
<a name="l00042"></a>00042         <span class="keyword">static</span> int32_t size;
<a name="l00043"></a>00043         <span class="keyword">static</span> uint8_t *stream_ptr;
<a name="l00044"></a>00044         
<a name="l00045"></a>00045         task_open();            <span class="comment">// standard OS entry - required on all tasks</span>
<a name="l00046"></a>00046 
<a name="l00047"></a>00047         <span class="keywordflow">for</span> (;;) {
<a name="l00048"></a>00048                 count = read_serial(tmp_buf, <span class="keyword">sizeof</span>(tmp_buf));  <span class="comment">// get block of bytes from serial port</span>
<a name="l00049"></a>00049                 <span class="keywordflow">for</span> (i = 0; i &lt; count; --i) {                                   <span class="comment">// process block</span>
<a name="l00050"></a>00050                         <span class="keywordflow">if</span> ((size = process_serial_byte(tmp_buf[i]) &gt; 0)) {     <span class="comment">// if we receieved a full packet/command</span>
<a name="l00051"></a>00051                                 
<a name="l00052"></a>00052                                 <span class="comment">//while (flash_busy())                    // flash resource may be needed, make sure it is </span>
<a name="l00053"></a>00053                                 task_wait(10);                                          <span class="comment">// available before proceeding</span>
<a name="l00054"></a>00054                                 
<a name="l00055"></a>00055                                 size = process_packet(packet, size);    <span class="comment">// go do it, response returns in same packet</span>
<a name="l00056"></a>00056                                 <span class="keywordflow">if</span> (size &gt; 0) {                                                 <span class="comment">// if there is a response to send</span>
<a name="l00057"></a>00057                                         
<a name="l00058"></a>00058                                         size = packetize_output(packet, stream, size);   <span class="comment">// convert packet to stream</span>
<a name="l00059"></a>00059                                         stream_ptr = stream;
<a name="l00060"></a>00060 
<a name="l00061"></a>00061                                         <span class="keywordflow">while</span> (size &gt; 0) {                      <span class="comment">// loop to send it out</span>
<a name="l00062"></a>00062                                                 <span class="keywordflow">while</span> (write_serial_busy())
<a name="l00063"></a>00063                                                 task_wait(4);           <span class="comment">// let other tasks run while waiting for Q to empty</span>
<a name="l00064"></a>00064 
<a name="l00065"></a>00065                                                 <span class="comment">// send as much of response as possible</span>
<a name="l00066"></a>00066                                                 <span class="keyword">static</span> uint_fast16_t bsize;
<a name="l00067"></a>00067                                                 bsize = min(size, SERIAL_BUFFER_SIZE);
<a name="l00068"></a>00068                                                 write_serial((<span class="keyword">const</span> uint8_t *) stream_ptr, bsize);      <span class="comment">// send response</span>
<a name="l00069"></a>00069                                                 stream_ptr += bsize;    <span class="comment">// move to remaining bytes</span>
<a name="l00070"></a>00070                                                 size -= bsize;                  <span class="comment">// track remaining</span>
<a name="l00071"></a>00071                                         }
<a name="l00072"></a>00072 
<a name="l00073"></a>00073                                 }       <span class="comment">// while</span>
<a name="l00074"></a>00074                                 task_wait(1);   <span class="comment">// let other tasks run </span>
<a name="l00075"></a>00075                         }       <span class="comment">// for</span>
<a name="l00076"></a>00076                 }
<a name="l00077"></a>00077                 task_wait(10);  <span class="comment">// let other tasks run  - this value is critical to prevent Q overflow</span>
<a name="l00078"></a>00078         }                       <span class="comment">// for ever</span>
<a name="l00079"></a>00079         task_close();
<a name="l00080"></a>00080 }                               <span class="comment">// tuner_task()</span>
<a name="l00081"></a>00081 
<a name="l00082"></a>00082 <span class="comment">// calc an error prone, slow, overly simple 16 (or 8) bit checksum on some bytes</span>
<a name="l00083"></a>00083 uint16_t checksum(<span class="keyword">const</span> uint8_t * addr, <span class="keyword">const</span> uint_fast16_t count)
<a name="l00084"></a>00084 {
<a name="l00085"></a>00085         <span class="keyword">register</span> uint_fast16_t sum = 0;
<a name="l00086"></a>00086         <span class="keyword">register</span> uint_fast16_t n;
<a name="l00087"></a>00087 
<a name="l00088"></a>00088         n = count &gt;&gt; 3;
<a name="l00089"></a>00089         <span class="keywordflow">while</span> (n--) {           <span class="comment">// unrolled for speed</span>
<a name="l00090"></a>00090                 sum += *addr++; <span class="comment">// faster and cleaner than Duff&#39;s Device</span>
<a name="l00091"></a>00091                 sum += *addr++;
<a name="l00092"></a>00092                 sum += *addr++;
<a name="l00093"></a>00093                 sum += *addr++;
<a name="l00094"></a>00094                 sum += *addr++;
<a name="l00095"></a>00095                 sum += *addr++;
<a name="l00096"></a>00096                 sum += *addr++;
<a name="l00097"></a>00097                 sum += *addr++;
<a name="l00098"></a>00098         }
<a name="l00099"></a>00099         n = count &amp; 0x7;
<a name="l00100"></a>00100         <span class="keywordflow">while</span> (n--)             <span class="comment">// remainder - not worth worrying about</span>
<a name="l00101"></a>00101         sum += *addr++;
<a name="l00102"></a>00102 
<a name="l00103"></a>00103         <span class="keywordflow">return</span> sum;
<a name="l00104"></a>00104 }                               <span class="comment">// checksum()</span>
<a name="l00105"></a>00105 
<a name="l00106"></a>00106 <span class="preprocessor">#if 0</span>
<a name="l00107"></a>00107 <span class="preprocessor"></span><span class="comment">// example of fixed address</span>
<a name="l00108"></a>00108 <span class="preprocessor">#pragma push</span>
<a name="l00109"></a>00109 <span class="preprocessor"></span><span class="preprocessor">#pragma section code_type &quot;.abs.00010000&quot; code_mode=pc_rel</span>
<a name="l00110"></a>00110 <span class="preprocessor"></span><span class="keywordtype">void</span> func(<span class="keywordtype">void</span>)
<a name="l00111"></a>00111 {
<a name="l00112"></a>00112 }
<a name="l00113"></a>00113 <span class="preprocessor">#pragma pop</span>
<a name="l00114"></a>00114 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00115"></a>00115 <span class="preprocessor"></span>
<a name="l00116"></a>00116 <span class="preprocessor">#if 0</span>
<a name="l00117"></a>00117 <span class="preprocessor"></span>Notes:
<a name="l00118"></a>00118 <span class="stringliteral">&#39;poll&#39;</span> the DONE and PEG 
<a name="l00119"></a>00119 Flash M0 0x40000
<a name="l00120"></a>00120 Flash H0 0x80000
<a name="l00121"></a>00121 
<a name="l00122"></a>00122 
<a name="l00123"></a>00123 <span class="comment">// Take all the current tables, wherever they are, and write them to a new flash block</span>
<a name="l00124"></a>00124 
<a name="l00125"></a>00125 flash_write_task() {
<a name="l00126"></a>00126 
<a name="l00127"></a>00127         <span class="comment">// select unused new flash block (ping pongs 0 or 1)</span>
<a name="l00128"></a>00128         new_flash_block = (flash_block == 0) ? 1 : 0;
<a name="l00129"></a>00129 
<a name="l00130"></a>00130         new_flash_addr = ???0x40000 + 0x40000 * flash_block;   <span class="comment">// M0 or H0 block</span>
<a name="l00131"></a>00131         <span class="comment">// verify that new flash block is erased </span>
<a name="l00132"></a>00132         <span class="keywordflow">if</span> (*new_flash_addr != 0xffffffff) {
<a name="l00133"></a>00133                 <span class="comment">// erase it</span>
<a name="l00134"></a>00134                 Flash_Erase(new_flash_block);
<a name="l00135"></a>00135                 <span class="keywordflow">while</span> (!Flash_Ready()) 
<a name="l00136"></a>00136                 os_wait(100);
<a name="l00137"></a>00137         }
<a name="l00138"></a>00138 
<a name="l00139"></a>00139         <span class="comment">// write each table to new flash(8 byte alignment, attend to other tasks every 8 bytes)</span>
<a name="l00140"></a>00140         flash_ptr = new_flash_addr;
<a name="l00141"></a>00141         <span class="comment">// reserve room for header (magic cookie, table of tables)</span>
<a name="l00142"></a>00142         flash_ptr += <span class="keyword">sizeof</span>(<span class="keyword">struct </span>ToT_header) + sizeof(struct TableOfTable);
<a name="l00143"></a>00143 
<a name="l00144"></a>00144 
<a name="l00145"></a>00145         Flash_Erase(1);
<a name="l00146"></a>00146         <span class="keywordflow">while</span> (!Flash_Ready()) {};
<a name="l00147"></a>00147         Flash_Finish();
<a name="l00148"></a>00148         Flash_Program(BLOCK0,array,0);
<a name="l00149"></a>00149         
<a name="l00150"></a>00150         
<a name="l00151"></a>00151         <span class="comment">// for each table, write to new flash</span>
<a name="l00152"></a>00152         <span class="keywordflow">for</span> (i = 0; i &lt; MAX_TABLES; ++i )
<a name="l00153"></a>00153         <span class="comment">// update table of tables with new flash address</span>
<a name="l00154"></a>00154         table-&gt;flash_address = flash_ptr;
<a name="l00155"></a>00155 
<a name="l00156"></a>00156         count = tablesize(table[i]);
<a name="l00157"></a>00157         <span class="comment">// find it (in current flash or ram)</span>
<a name="l00158"></a>00158         ptr = xx&amp;table[i];
<a name="l00159"></a>00159 
<a name="l00160"></a>00160         <span class="comment">// write 8 bytes at a time</span>
<a name="l00161"></a>00161         <span class="keywordflow">while</span> (count &gt; 0) {
<a name="l00162"></a>00162                 i = min(count,8);
<a name="l00163"></a>00163                 Flash_Program(ptr,flash_ptr,i);
<a name="l00164"></a>00164                 count -= i;
<a name="l00165"></a>00165                 flash_ptr = i;
<a name="l00166"></a>00166                 <span class="keywordflow">while</span> (!Flash_Ready()) 
<a name="l00167"></a>00167                 task_wait(1);          <span class="comment">// run other tasks</span>
<a name="l00168"></a>00168                 Flash_Finish();
<a name="l00169"></a>00169         } <span class="comment">// while</span>
<a name="l00170"></a>00170 } <span class="comment">// for</span>
<a name="l00171"></a>00171 
<a name="l00172"></a>00172 <span class="comment">// write new table of tables to new flash</span>
<a name="l00173"></a>00173 flash_ptr = new_flash_addr + <span class="keyword">sizeof</span>(<span class="keyword">struct </span>TofT_header);
<a name="l00174"></a>00174 <span class="keywordflow">while</span> (count &gt; 0) {
<a name="l00175"></a>00175         write_flash(table_of_tables,flash_ptr,<span class="keyword">sizeof</span>(table_of_tables));
<a name="l00176"></a>00176         <span class="keywordflow">while</span> (!Flash_Ready()) 
<a name="l00177"></a>00177         task_wait(1);          <span class="comment">// run other tasks</span>
<a name="l00178"></a>00178         Flash_Finish();
<a name="l00179"></a>00179 }
<a name="l00180"></a>00180 
<a name="l00181"></a>00181 <span class="comment">// write magic cookie (4 bytes + 4 byte serial #)</span>
<a name="l00182"></a>00182 flash_ptr = new_flash_addr;
<a name="l00183"></a>00183 ++TofT_header-&gt;serial_number;
<a name="l00184"></a>00184 Flash_Program(flash_header,xxflash_ptr,<span class="keyword">sizeof</span>(flash_header));
<a name="l00185"></a>00185 <span class="keywordflow">while</span> (!Flash_Ready()) 
<a name="l00186"></a>00186 task_wait(1);          <span class="comment">// run other tasks</span>
<a name="l00187"></a>00187 Flash_Finish();
<a name="l00188"></a>00188 
<a name="l00189"></a>00189 <span class="comment">// update working copy of TofT + pointers</span>
<a name="l00190"></a>00190 <span class="comment">// note: now running from tables in new flash</span>
<a name="l00191"></a>00191 <span class="comment">// release ram used(free()) by tables in ram</span>
<a name="l00192"></a>00192 <span class="keywordflow">for</span> (i = 0; i &lt; MAX_TABLES; ++i )
<a name="l00193"></a>00193 <span class="keywordflow">if</span> (in_ram(table[i]) 
<a name="l00194"></a>00194                 free(table[i]);
<a name="l00195"></a>00195 
<a name="l00196"></a>00196                 <span class="comment">// erase old flash block while running other tasks</span>
<a name="l00197"></a>00197                 Flash_Erase(old_flash_block);
<a name="l00198"></a>00198                 <span class="keywordflow">while</span> (!Flash_Ready) 
<a name="l00199"></a>00199                 os_wait(100);
<a name="l00200"></a>00200                 Flash_Finish();
<a name="l00201"></a>00201                 
<a name="l00202"></a>00202                 <span class="comment">// exit task</span>
<a name="l00203"></a>00203                 
<a name="l00204"></a>00204                 SRAM_START SRAM_END ? ? FLASH1_START ? ? FLASH2_START
<a name="l00205"></a>00205 <span class="preprocessor">#endif</span>
<a name="l00206"></a>00206 <span class="preprocessor"></span>
</pre></div></div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address style="text-align: right;"><small>Generated on Mon Nov 14 12:33:03 2011 for O5E by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
