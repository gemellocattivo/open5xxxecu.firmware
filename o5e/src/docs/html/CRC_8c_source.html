<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>O5E: CRC.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    </ul>
  </div>
<h1>CRC.c</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*----------------------------------------------------------------------------*\</span>
<a name="l00002"></a>00002 <span class="comment"> *  CRC-32 version 2.0.0 by Craig Bruce, 2006-04-29.</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> *  This program generates the CRC-32 values for the files named in the</span>
<a name="l00005"></a>00005 <span class="comment"> *  command-line arguments.  These are the same CRC-32 values used by GZIP,</span>
<a name="l00006"></a>00006 <span class="comment"> *  PKZIP, and ZMODEM.  The Crc32_ComputeBuf() can also be detached and</span>
<a name="l00007"></a>00007 <span class="comment"> *  used independently.</span>
<a name="l00008"></a>00008 <span class="comment"> *</span>
<a name="l00009"></a>00009 <span class="comment"> *  THIS PROGRAM IS PUBLIC-DOMAIN SOFTWARE.</span>
<a name="l00010"></a>00010 <span class="comment"> *</span>
<a name="l00011"></a>00011 <span class="comment"> *  Based on the byte-oriented implementation &quot;File Verification Using CRC&quot;</span>
<a name="l00012"></a>00012 <span class="comment"> *  by Mark R. Nelson in Dr. Dobb&#39;s Journal, May 1992, pp. 64-67.</span>
<a name="l00013"></a>00013 <span class="comment"> *</span>
<a name="l00014"></a>00014 <span class="comment"> *  v1.0.0: original release.</span>
<a name="l00015"></a>00015 <span class="comment"> *  v1.0.1: fixed printf formats.</span>
<a name="l00016"></a>00016 <span class="comment"> *  v1.0.2: fixed something else.</span>
<a name="l00017"></a>00017 <span class="comment"> *  v1.0.3: replaced CRC constant table by generator function.</span>
<a name="l00018"></a>00018 <span class="comment"> *  v1.0.4: reformatted code, made ANSI C.  1994-12-05.</span>
<a name="l00019"></a>00019 <span class="comment"> *  v2.0.0: rewrote to use memory buffer &amp; static table, 2006-04-29.</span>
<a name="l00020"></a>00020 <span class="comment">\*----------------------------------------------------------------------------*/</span>
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;stdint.h&gt;</span>
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 <span class="comment">/*----------------------------------------------------------------------------*\</span>
<a name="l00026"></a>00026 <span class="comment"> *  Local functions</span>
<a name="l00027"></a>00027 <span class="comment">\*----------------------------------------------------------------------------*/</span>
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> Crc32_ComputeBuf(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> inCrc32, <span class="keyword">const</span> <span class="keywordtype">void</span> *buf,
<a name="l00030"></a>00030                                       <span class="keywordtype">size_t</span> bufLen);
<a name="l00031"></a>00031 
<a name="l00032"></a>00032 <span class="comment">/*----------------------------------------------------------------------------*\</span>
<a name="l00033"></a>00033 <span class="comment"> *  NAME:</span>
<a name="l00034"></a>00034 <span class="comment"> *     Crc32_ComputeBuf() - computes the CRC-32 value of a memory buffer</span>
<a name="l00035"></a>00035 <span class="comment"> *  DESCRIPTION:</span>
<a name="l00036"></a>00036 <span class="comment"> *     Computes or accumulates the CRC-32 value for a memory buffer.</span>
<a name="l00037"></a>00037 <span class="comment"> *     The &#39;inCrc32&#39; gives a previously accumulated CRC-32 value to allow</span>
<a name="l00038"></a>00038 <span class="comment"> *     a CRC to be generated for multiple sequential buffer-fuls of data.</span>
<a name="l00039"></a>00039 <span class="comment"> *     The &#39;inCrc32&#39; for the first buffer must be zero.</span>
<a name="l00040"></a>00040 <span class="comment"> *  ARGUMENTS:</span>
<a name="l00041"></a>00041 <span class="comment"> *     inCrc32 - accumulated CRC-32 value, must be 0 on first call</span>
<a name="l00042"></a>00042 <span class="comment"> *     buf     - buffer to compute CRC-32 value for</span>
<a name="l00043"></a>00043 <span class="comment"> *     bufLen  - number of bytes in buffer</span>
<a name="l00044"></a>00044 <span class="comment"> *  RETURNS:</span>
<a name="l00045"></a>00045 <span class="comment"> *     crc32 - computed CRC-32 value</span>
<a name="l00046"></a>00046 <span class="comment"> *  ERRORS:</span>
<a name="l00047"></a>00047 <span class="comment"> *     (no errors are possible)</span>
<a name="l00048"></a>00048 <span class="comment">\*----------------------------------------------------------------------------*/</span>
<a name="l00049"></a>00049 
<a name="l00050"></a>00050 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> Crc32_ComputeBuf(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> inCrc32, <span class="keyword">const</span> <span class="keywordtype">void</span> *buf,
<a name="l00051"></a>00051                                       <span class="keywordtype">size_t</span> bufLen)
<a name="l00052"></a>00052 {
<a name="l00053"></a>00053         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> crcTable[256] = {
<a name="l00054"></a>00054                 0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419,
<a name="l00055"></a>00055                     0x706AF48F, 0xE963A535,
<a name="l00056"></a>00056                 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
<a name="l00057"></a>00057                     0x09B64C2B, 0x7EB17CBD,
<a name="l00058"></a>00058                 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2, 0xF3B97148,
<a name="l00059"></a>00059                     0x84BE41DE, 0x1ADAD47D,
<a name="l00060"></a>00060                 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, 0x136C9856, 0x646BA8C0,
<a name="l00061"></a>00061                     0xFD62F97A, 0x8A65C9EC,
<a name="l00062"></a>00062                 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8,
<a name="l00063"></a>00063                     0x4C69105E, 0xD56041E4,
<a name="l00064"></a>00064                 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
<a name="l00065"></a>00065                     0x35B5A8FA, 0x42B2986C,
<a name="l00066"></a>00066                 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF,
<a name="l00067"></a>00067                     0xABD13D59, 0x26D930AC,
<a name="l00068"></a>00068                 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,
<a name="l00069"></a>00069                     0xCFBA9599, 0xB8BDA50F,
<a name="l00070"></a>00070                 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87,
<a name="l00071"></a>00071                     0x58684C11, 0xC1611DAB,
<a name="l00072"></a>00072                 0xB6662D3D, 0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A,
<a name="l00073"></a>00073                     0x71B18589, 0x06B6B51F,
<a name="l00074"></a>00074                 0x9FBFE4A5, 0xE8B8D433, 0x7807C9A2, 0x0F00F934, 0x9609A88E,
<a name="l00075"></a>00075                     0xE10E9818, 0x7F6A0DBB,
<a name="l00076"></a>00076                 0x086D3D2D, 0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162,
<a name="l00077"></a>00077                     0x856530D8, 0xF262004E,
<a name="l00078"></a>00078                 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6,
<a name="l00079"></a>00079                     0x12B7E950, 0x8BBEB8EA,
<a name="l00080"></a>00080                 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
<a name="l00081"></a>00081                     0x4DB26158, 0x3AB551CE,
<a name="l00082"></a>00082                 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D,
<a name="l00083"></a>00083                     0xD3D6F4FB, 0x4369E96A,
<a name="l00084"></a>00084                 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5,
<a name="l00085"></a>00085                     0xAA0A4C5F, 0xDD0D7CC9,
<a name="l00086"></a>00086                 0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525,
<a name="l00087"></a>00087                     0x206F85B3, 0xB966D409,
<a name="l00088"></a>00088                 0xCE61E49F, 0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4,
<a name="l00089"></a>00089                     0x59B33D17, 0x2EB40D81,
<a name="l00090"></a>00090                 0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C,
<a name="l00091"></a>00091                     0x74B1D29A, 0xEAD54739,
<a name="l00092"></a>00092                 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84,
<a name="l00093"></a>00093                     0x0D6D6A3E, 0x7A6A5AA8,
<a name="l00094"></a>00094                 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 0xF00F9344,
<a name="l00095"></a>00095                     0x8708A3D2, 0x1E01F268,
<a name="l00096"></a>00096                 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,
<a name="l00097"></a>00097                     0xFED41B76, 0x89D32BE0,
<a name="l00098"></a>00098                 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43,
<a name="l00099"></a>00099                     0x60B08ED5, 0xD6D6A3E8,
<a name="l00100"></a>00100                 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767,
<a name="l00101"></a>00101                     0x3FB506DD, 0x48B2364B,
<a name="l00102"></a>00102                 0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3,
<a name="l00103"></a>00103                     0xA867DF55, 0x316E8EEF,
<a name="l00104"></a>00104                 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
<a name="l00105"></a>00105                     0xCC0C7795, 0xBB0B4703,
<a name="l00106"></a>00106                 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92,
<a name="l00107"></a>00107                     0x5CB36A04, 0xC2D7FFA7,
<a name="l00108"></a>00108                 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D, 0x9B64C2B0, 0xEC63F226,
<a name="l00109"></a>00109                     0x756AA39C, 0x026D930A,
<a name="l00110"></a>00110                 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713, 0x95BF4A82,
<a name="l00111"></a>00111                     0xE2B87A14, 0x7BB12BAE,
<a name="l00112"></a>00112                 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
<a name="l00113"></a>00113                     0x86D3D2D4, 0xF1D4E242,
<a name="l00114"></a>00114                 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1,
<a name="l00115"></a>00115                     0x18B74777, 0x88085AE6,
<a name="l00116"></a>00116                 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69,
<a name="l00117"></a>00117                     0x616BFFD3, 0x166CCF45,
<a name="l00118"></a>00118                 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661,
<a name="l00119"></a>00119                     0xD06016F7, 0x4969474D,
<a name="l00120"></a>00120                 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0,
<a name="l00121"></a>00121                     0xA9BCAE53, 0xDEBB9EC5,
<a name="l00122"></a>00122                 0x47B2CF7F, 0x30B5FFE9, 0xBDBDF21C, 0xCABAC28A, 0x53B39330,
<a name="l00123"></a>00123                     0x24B4A3A6, 0xBAD03605,
<a name="l00124"></a>00124                 0xCDD70693, 0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8,
<a name="l00125"></a>00125                     0x5D681B02, 0x2A6F2B94,
<a name="l00126"></a>00126                 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
<a name="l00127"></a>00127         };
<a name="l00128"></a>00128         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> crc32;
<a name="l00129"></a>00129         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *byteBuf;
<a name="l00130"></a>00130         <span class="keywordtype">size_t</span> i;
<a name="l00131"></a>00131 
<a name="l00133"></a>00133         crc32 = inCrc32 ^ 0xFFFFFFFF;
<a name="l00134"></a>00134         byteBuf = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)buf;
<a name="l00135"></a>00135 
<a name="l00136"></a>00136         <span class="keywordflow">for</span> (i = 0; i &lt; bufLen; i++) {
<a name="l00137"></a>00137                 crc32 = (crc32 &gt;&gt; 8) ^ crcTable[(crc32 ^ byteBuf[i]) &amp; 0xFF];
<a name="l00138"></a>00138         }
<a name="l00139"></a>00139 
<a name="l00140"></a>00140         <span class="keywordflow">return</span> (crc32 ^ 0xFFFFFFFF);
<a name="l00141"></a>00141 }
<a name="l00142"></a>00142 
<a name="l00143"></a>00143 <span class="comment">/*----------------------------------------------------------------------------*\</span>
<a name="l00144"></a>00144 <span class="comment"> *  END OF MODULE: crc32.c</span>
<a name="l00145"></a>00145 <span class="comment">\*----------------------------------------------------------------------------*/</span>
<a name="l00146"></a>00146 
<a name="l00147"></a>00147 <span class="preprocessor">#if 0</span>
<a name="l00148"></a>00148 <span class="preprocessor"></span>
<a name="l00149"></a>00149 <span class="comment">/**********************************************************************</span>
<a name="l00150"></a>00150 <span class="comment"> *</span>
<a name="l00151"></a>00151 <span class="comment"> * Filename:    crc.c</span>
<a name="l00152"></a>00152 <span class="comment"> * </span>
<a name="l00153"></a>00153 <span class="comment"> * Description: Slow and fast implementations of the CRC standards.</span>
<a name="l00154"></a>00154 <span class="comment"> *</span>
<a name="l00155"></a>00155 <span class="comment"> * Notes:       The parameters for each supported CRC standard are</span>
<a name="l00156"></a>00156 <span class="comment"> *                              defined in the header file crc.h.  The implementations</span>
<a name="l00157"></a>00157 <span class="comment"> *                              here should stand up to further additions to that list.</span>
<a name="l00158"></a>00158 <span class="comment"> *</span>
<a name="l00159"></a>00159 <span class="comment"> * </span>
<a name="l00160"></a>00160 <span class="comment"> * Copyright (c) 2000 by Michael Barr.  This software is placed into</span>
<a name="l00161"></a>00161 <span class="comment"> * the public domain and may be used for any purpose.  However, this</span>
<a name="l00162"></a>00162 <span class="comment"> * notice must not be changed or removed and no warranty is either</span>
<a name="l00163"></a>00163 <span class="comment"> * expressed or implied by its publication or distribution.</span>
<a name="l00164"></a>00164 <span class="comment"> **********************************************************************/</span>
<a name="l00165"></a>00165 
<a name="l00166"></a>00166 <span class="preprocessor">#include &quot;inc/crc.h&quot;</span>
<a name="l00167"></a>00167 
<a name="l00168"></a>00168 <span class="comment">/*</span>
<a name="l00169"></a>00169 <span class="comment"> * Derive parameters from the standard-specific parameters in crc.h.</span>
<a name="l00170"></a>00170 <span class="comment"> */</span>
<a name="l00171"></a>00171 <span class="preprocessor">#define WIDTH    (8 * sizeof(crc))</span>
<a name="l00172"></a>00172 <span class="preprocessor"></span><span class="preprocessor">#define TOPBIT   (1 &lt;&lt; (WIDTH - 1))</span>
<a name="l00173"></a>00173 <span class="preprocessor"></span>
<a name="l00174"></a>00174 <span class="preprocessor">#if (REFLECT_DATA == TRUE)</span>
<a name="l00175"></a>00175 <span class="preprocessor"></span><span class="preprocessor">#undef  REFLECT_DATA</span>
<a name="l00176"></a>00176 <span class="preprocessor"></span><span class="preprocessor">#define REFLECT_DATA(X)                 ((unsigned char) reflect((X), 8))</span>
<a name="l00177"></a>00177 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00178"></a>00178 <span class="preprocessor"></span><span class="preprocessor">#undef  REFLECT_DATA</span>
<a name="l00179"></a>00179 <span class="preprocessor"></span><span class="preprocessor">#define REFLECT_DATA(X)                 (X)</span>
<a name="l00180"></a>00180 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00181"></a>00181 <span class="preprocessor"></span>
<a name="l00182"></a>00182 <span class="preprocessor">#if (REFLECT_REMAINDER == TRUE)</span>
<a name="l00183"></a>00183 <span class="preprocessor"></span><span class="preprocessor">#undef  REFLECT_REMAINDER</span>
<a name="l00184"></a>00184 <span class="preprocessor"></span><span class="preprocessor">#define REFLECT_REMAINDER(X)    ((crc) reflect((X), WIDTH))</span>
<a name="l00185"></a>00185 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00186"></a>00186 <span class="preprocessor"></span><span class="preprocessor">#undef  REFLECT_REMAINDER</span>
<a name="l00187"></a>00187 <span class="preprocessor"></span><span class="preprocessor">#define REFLECT_REMAINDER(X)    (X)</span>
<a name="l00188"></a>00188 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00189"></a>00189 <span class="preprocessor"></span>
<a name="l00190"></a>00190 <span class="comment">/*********************************************************************</span>
<a name="l00191"></a>00191 <span class="comment"> *</span>
<a name="l00192"></a>00192 <span class="comment"> * Function:    reflect()</span>
<a name="l00193"></a>00193 <span class="comment"> * </span>
<a name="l00194"></a>00194 <span class="comment"> * Description: Reorder the bits of a binary sequence, by reflecting</span>
<a name="l00195"></a>00195 <span class="comment"> *                              them about the middle position.</span>
<a name="l00196"></a>00196 <span class="comment"> *</span>
<a name="l00197"></a>00197 <span class="comment"> * Notes:               No checking is done that nBits &lt;= 32.</span>
<a name="l00198"></a>00198 <span class="comment"> *</span>
<a name="l00199"></a>00199 <span class="comment"> * Returns:             The reflection of the original data.</span>
<a name="l00200"></a>00200 <span class="comment"> *</span>
<a name="l00201"></a>00201 <span class="comment"> *********************************************************************/</span>
<a name="l00202"></a>00202 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> reflect(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> data, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> nBits)
<a name="l00203"></a>00203 {
<a name="l00204"></a>00204         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> reflection = 0x00000000;
<a name="l00205"></a>00205         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> bit;
<a name="l00206"></a>00206 
<a name="l00207"></a>00207         <span class="comment">/*</span>
<a name="l00208"></a>00208 <span class="comment">         * Reflect the data about the center bit.</span>
<a name="l00209"></a>00209 <span class="comment">         */</span>
<a name="l00210"></a>00210         <span class="keywordflow">for</span> (bit = 0; bit &lt; nBits; ++bit) {
<a name="l00211"></a>00211                 <span class="comment">/*</span>
<a name="l00212"></a>00212 <span class="comment">                 * If the LSB bit is set, set the reflection of it.</span>
<a name="l00213"></a>00213 <span class="comment">                 */</span>
<a name="l00214"></a>00214                 <span class="keywordflow">if</span> (data &amp; 0x01) {
<a name="l00215"></a>00215                         reflection |= (1 &lt;&lt; ((nBits - 1) - bit));
<a name="l00216"></a>00216                 }
<a name="l00217"></a>00217 
<a name="l00218"></a>00218                 data = (data &gt;&gt; 1);
<a name="l00219"></a>00219         }
<a name="l00220"></a>00220 
<a name="l00221"></a>00221         <span class="keywordflow">return</span> (reflection);
<a name="l00222"></a>00222 
<a name="l00223"></a>00223 }                               <span class="comment">/* reflect() */</span>
<a name="l00224"></a>00224 
<a name="l00225"></a>00225 <span class="comment">/*********************************************************************</span>
<a name="l00226"></a>00226 <span class="comment"> *</span>
<a name="l00227"></a>00227 <span class="comment"> * Function:    crcSlow()</span>
<a name="l00228"></a>00228 <span class="comment"> * </span>
<a name="l00229"></a>00229 <span class="comment"> * Description: Compute the CRC of a given message.</span>
<a name="l00230"></a>00230 <span class="comment"> *</span>
<a name="l00231"></a>00231 <span class="comment"> * Notes:               </span>
<a name="l00232"></a>00232 <span class="comment"> *</span>
<a name="l00233"></a>00233 <span class="comment"> * Returns:             The CRC of the message.</span>
<a name="l00234"></a>00234 <span class="comment"> *</span>
<a name="l00235"></a>00235 <span class="comment"> *********************************************************************/</span>
<a name="l00236"></a>00236 crc crcSlow(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <span class="keyword">const</span> message[], <span class="keywordtype">int</span> nBytes)
<a name="l00237"></a>00237 {
<a name="l00238"></a>00238         crc remainder = INITIAL_REMAINDER;
<a name="l00239"></a>00239         <span class="keywordtype">int</span> byte;
<a name="l00240"></a>00240         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> bit;
<a name="l00241"></a>00241 
<a name="l00242"></a>00242         <span class="comment">/*</span>
<a name="l00243"></a>00243 <span class="comment">         * Perform modulo-2 division, a byte at a time.</span>
<a name="l00244"></a>00244 <span class="comment">         */</span>
<a name="l00245"></a>00245         <span class="keywordflow">for</span> (byte = 0; byte &lt; nBytes; ++byte) {
<a name="l00246"></a>00246                 <span class="comment">/*</span>
<a name="l00247"></a>00247 <span class="comment">                 * Bring the next byte into the remainder.</span>
<a name="l00248"></a>00248 <span class="comment">                 */</span>
<a name="l00249"></a>00249                 remainder ^= (REFLECT_DATA(message[byte]) &lt;&lt; (WIDTH - 8));
<a name="l00250"></a>00250 
<a name="l00251"></a>00251                 <span class="comment">/*</span>
<a name="l00252"></a>00252 <span class="comment">                 * Perform modulo-2 division, a bit at a time.</span>
<a name="l00253"></a>00253 <span class="comment">                 */</span>
<a name="l00254"></a>00254                 <span class="keywordflow">for</span> (bit = 8; bit &gt; 0; --bit) {
<a name="l00255"></a>00255                         <span class="comment">/*</span>
<a name="l00256"></a>00256 <span class="comment">                         * Try to divide the current data bit.</span>
<a name="l00257"></a>00257 <span class="comment">                         */</span>
<a name="l00258"></a>00258                         <span class="keywordflow">if</span> (remainder &amp; TOPBIT) {
<a name="l00259"></a>00259                                 remainder = (remainder &lt;&lt; 1) ^ POLYNOMIAL;
<a name="l00260"></a>00260                         } <span class="keywordflow">else</span> {
<a name="l00261"></a>00261                                 remainder = (remainder &lt;&lt; 1);
<a name="l00262"></a>00262                         }
<a name="l00263"></a>00263                 }
<a name="l00264"></a>00264         }
<a name="l00265"></a>00265 
<a name="l00266"></a>00266         <span class="comment">/*</span>
<a name="l00267"></a>00267 <span class="comment">         * The final remainder is the CRC result.</span>
<a name="l00268"></a>00268 <span class="comment">         */</span>
<a name="l00269"></a>00269         <span class="keywordflow">return</span> (REFLECT_REMAINDER(remainder) ^ FINAL_XOR_VALUE);
<a name="l00270"></a>00270 
<a name="l00271"></a>00271 }                               <span class="comment">/* crcSlow() */</span>
<a name="l00272"></a>00272 
<a name="l00273"></a>00273 crc crcTable[256];
<a name="l00274"></a>00274 
<a name="l00275"></a>00275 <span class="comment">/*********************************************************************</span>
<a name="l00276"></a>00276 <span class="comment"> *</span>
<a name="l00277"></a>00277 <span class="comment"> * Function:    crcInit()</span>
<a name="l00278"></a>00278 <span class="comment"> * </span>
<a name="l00279"></a>00279 <span class="comment"> * Description: Populate the partial CRC lookup table.</span>
<a name="l00280"></a>00280 <span class="comment"> *</span>
<a name="l00281"></a>00281 <span class="comment"> * Notes:               This function must be rerun any time the CRC standard</span>
<a name="l00282"></a>00282 <span class="comment"> *                              is changed.  If desired, it can be run &quot;offline&quot; and</span>
<a name="l00283"></a>00283 <span class="comment"> *                              the table results stored in an embedded system&#39;s ROM.</span>
<a name="l00284"></a>00284 <span class="comment"> *</span>
<a name="l00285"></a>00285 <span class="comment"> * Returns:             None defined.</span>
<a name="l00286"></a>00286 <span class="comment"> *</span>
<a name="l00287"></a>00287 <span class="comment"> *********************************************************************/</span>
<a name="l00288"></a>00288 <span class="keywordtype">void</span> crcInit(<span class="keywordtype">void</span>)
<a name="l00289"></a>00289 {
<a name="l00290"></a>00290         crc remainder;
<a name="l00291"></a>00291         <span class="keywordtype">int</span> dividend;
<a name="l00292"></a>00292         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> bit;
<a name="l00293"></a>00293 
<a name="l00294"></a>00294         <span class="comment">/*</span>
<a name="l00295"></a>00295 <span class="comment">         * Compute the remainder of each possible dividend.</span>
<a name="l00296"></a>00296 <span class="comment">         */</span>
<a name="l00297"></a>00297         <span class="keywordflow">for</span> (dividend = 0; dividend &lt; 256; ++dividend) {
<a name="l00298"></a>00298                 <span class="comment">/*</span>
<a name="l00299"></a>00299 <span class="comment">                 * Start with the dividend followed by zeros.</span>
<a name="l00300"></a>00300 <span class="comment">                 */</span>
<a name="l00301"></a>00301                 remainder = dividend &lt;&lt; (WIDTH - 8);
<a name="l00302"></a>00302 
<a name="l00303"></a>00303                 <span class="comment">/*</span>
<a name="l00304"></a>00304 <span class="comment">                 * Perform modulo-2 division, a bit at a time.</span>
<a name="l00305"></a>00305 <span class="comment">                 */</span>
<a name="l00306"></a>00306                 <span class="keywordflow">for</span> (bit = 8; bit &gt; 0; --bit) {
<a name="l00307"></a>00307                         <span class="comment">/*</span>
<a name="l00308"></a>00308 <span class="comment">                         * Try to divide the current data bit.</span>
<a name="l00309"></a>00309 <span class="comment">                         */</span>
<a name="l00310"></a>00310                         <span class="keywordflow">if</span> (remainder &amp; TOPBIT) {
<a name="l00311"></a>00311                                 remainder = (remainder &lt;&lt; 1) ^ POLYNOMIAL;
<a name="l00312"></a>00312                         } <span class="keywordflow">else</span> {
<a name="l00313"></a>00313                                 remainder = (remainder &lt;&lt; 1);
<a name="l00314"></a>00314                         }
<a name="l00315"></a>00315                 }
<a name="l00316"></a>00316 
<a name="l00317"></a>00317                 <span class="comment">/*</span>
<a name="l00318"></a>00318 <span class="comment">                 * Store the result into the table.</span>
<a name="l00319"></a>00319 <span class="comment">                 */</span>
<a name="l00320"></a>00320                 crcTable[dividend] = remainder;
<a name="l00321"></a>00321         }
<a name="l00322"></a>00322 
<a name="l00323"></a>00323 }                               <span class="comment">/* crcInit() */</span>
<a name="l00324"></a>00324 
<a name="l00325"></a>00325 <span class="comment">/*********************************************************************</span>
<a name="l00326"></a>00326 <span class="comment"> *</span>
<a name="l00327"></a>00327 <span class="comment"> * Function:    crcFast()</span>
<a name="l00328"></a>00328 <span class="comment"> * </span>
<a name="l00329"></a>00329 <span class="comment"> * Description: Compute the CRC of a given message.</span>
<a name="l00330"></a>00330 <span class="comment"> *</span>
<a name="l00331"></a>00331 <span class="comment"> * Notes:               crcInit() must be called first.</span>
<a name="l00332"></a>00332 <span class="comment"> *</span>
<a name="l00333"></a>00333 <span class="comment"> * Returns:             The CRC of the message.</span>
<a name="l00334"></a>00334 <span class="comment"> *</span>
<a name="l00335"></a>00335 <span class="comment"> *********************************************************************/</span>
<a name="l00336"></a>00336 crc crcFast(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <span class="keyword">const</span> message[], <span class="keywordtype">int</span> nBytes)
<a name="l00337"></a>00337 {
<a name="l00338"></a>00338         crc remainder = INITIAL_REMAINDER;
<a name="l00339"></a>00339         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> data;
<a name="l00340"></a>00340         <span class="keywordtype">int</span> byte;
<a name="l00341"></a>00341 
<a name="l00342"></a>00342         <span class="comment">/*</span>
<a name="l00343"></a>00343 <span class="comment">         * Divide the message by the polynomial, a byte at a time.</span>
<a name="l00344"></a>00344 <span class="comment">         */</span>
<a name="l00345"></a>00345         <span class="keywordflow">for</span> (byte = 0; byte &lt; nBytes; ++byte) {
<a name="l00346"></a>00346                 data = REFLECT_DATA(message[byte]) ^ (remainder &gt;&gt; (WIDTH - 8));
<a name="l00347"></a>00347                 remainder = crcTable[data] ^ (remainder &lt;&lt; 8);
<a name="l00348"></a>00348         }
<a name="l00349"></a>00349 
<a name="l00350"></a>00350         <span class="comment">/*</span>
<a name="l00351"></a>00351 <span class="comment">         * The final remainder is the CRC.</span>
<a name="l00352"></a>00352 <span class="comment">         */</span>
<a name="l00353"></a>00353         <span class="keywordflow">return</span> (REFLECT_REMAINDER(remainder) ^ FINAL_XOR_VALUE);
<a name="l00354"></a>00354 
<a name="l00355"></a>00355 }                               <span class="comment">/* crcFast() */</span>
<a name="l00356"></a>00356 
<a name="l00357"></a>00357 main()
<a name="l00358"></a>00358 {
<a name="l00359"></a>00359         uint32_t result;
<a name="l00360"></a>00360 
<a name="l00361"></a>00361         result = Crc32_ComputeBuf(0, crcTable, 1024);
<a name="l00362"></a>00362         printf(<span class="stringliteral">&quot;result = %u\n&quot;</span>, result);
<a name="l00363"></a>00363 
<a name="l00364"></a>00364         crcInit();
<a name="l00365"></a>00365         result = crcFast((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)crcTable, 1024);
<a name="l00366"></a>00366         printf(<span class="stringliteral">&quot;result = %u\n&quot;</span>, result);
<a name="l00367"></a>00367 
<a name="l00368"></a>00368         result = crcSlow((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)crcTable, 1024);
<a name="l00369"></a>00369         printf(<span class="stringliteral">&quot;result = %u\n&quot;</span>, result);
<a name="l00370"></a>00370 }
<a name="l00371"></a>00371 
<a name="l00372"></a>00372 <span class="preprocessor">#endif</span>
</pre></div></div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address style="text-align: right;"><small>Generated on Mon Nov 14 12:33:03 2011 for O5E by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
