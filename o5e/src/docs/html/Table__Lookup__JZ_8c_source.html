<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>O5E: Table_Lookup_JZ.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    </ul>
  </div>
<h1>Table_Lookup_JZ.c</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/**************************************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment"></span>
<a name="l00003"></a>00003 <span class="comment">        @file           table_lookup_jz.c</span>
<a name="l00004"></a>00004 <span class="comment">        @author         Jon Zeeff</span>
<a name="l00005"></a>00005 <span class="comment">        @date           September, 2011</span>
<a name="l00006"></a>00006 <span class="comment">        @brief          table lookup - fast, generic, 1D, 3D, variable axis, fixed axis, int16_t or uint8_t, binary search </span>
<a name="l00007"></a>00007 <span class="comment">        @copyright      MIT license</span>
<a name="l00008"></a>00008 <span class="comment">        @warning        needs more testing - send results to jon@zeeff.com</span>
<a name="l00009"></a>00009 <span class="comment">        @version        1.2</span>
<a name="l00010"></a>00010 <span class="comment">        </span>
<a name="l00011"></a>00011 <span class="comment">        @note Generic, portable 1D or 2D table lookup</span>
<a name="l00012"></a>00012 <span class="comment">        Can use a fixed interval on the axis (tends to need more points to get accuracy but is faster)</span>
<a name="l00013"></a>00013 <span class="comment">        Table entries are int16_t (which will usually work with unsigned values too) or 8 bit unsigned</span>
<a name="l00014"></a>00014 <span class="comment">        Works with any bin point</span>
<a name="l00015"></a>00015 <span class="comment">        Uses a binary search when doing variable axis increments (faster)</span>
<a name="l00016"></a>00016 <span class="comment">        Linear search is available if you have small tables</span>
<a name="l00017"></a>00017 <span class="comment">        Logs errors if desired</span>
<a name="l00018"></a>00018 <span class="comment">        Does range and error checks</span>
<a name="l00019"></a>00019 <span class="comment">        ISO C90 compatible (yuck, check with &quot;gcc -Wall -pedantic -Wextra&quot;)</span>
<a name="l00020"></a>00020 <span class="comment">        </span>
<a name="l00021"></a>00021 <span class="comment">        To use this, you need to fill out a table_jz structure and then pass the lookup </span>
<a name="l00022"></a>00022 <span class="comment">        routine a pointer to the structure.</span>
<a name="l00023"></a>00023 <span class="comment">        </span>
<a name="l00024"></a>00024 <span class="comment">****************************************************************************************************/</span>
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <span class="comment">/* </span>
<a name="l00027"></a>00027 <span class="comment"></span>
<a name="l00028"></a>00028 <span class="comment">Copyright (c) 2011 Jon Zeeff</span>
<a name="l00029"></a>00029 <span class="comment"></span>
<a name="l00030"></a>00030 <span class="comment">Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</span>
<a name="l00031"></a>00031 <span class="comment"></span>
<a name="l00032"></a>00032 <span class="comment">The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</span>
<a name="l00033"></a>00033 <span class="comment"></span>
<a name="l00034"></a>00034 <span class="comment">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span>
<a name="l00035"></a>00035 <span class="comment"></span>
<a name="l00036"></a>00036 <span class="comment">*/</span>
<a name="l00037"></a>00037 
<a name="l00038"></a>00038 <span class="preprocessor">#include &lt;stdint.h&gt;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &quot;inc/Table_Lookup_JZ.h&quot;</span>
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 <span class="comment">/* Use this if you don&#39;t have error logging */</span>
<a name="l00042"></a>00042 <span class="preprocessor">#define system_error(a,b,c,d)           </span><span class="comment">/* a routine to log a string */</span>
<a name="l00043"></a>00043 <span class="comment">/*  #define MAIN if you want to test this as a standalone program on a PC */</span>
<a name="l00044"></a>00044 <span class="comment">/* #define MAIN */</span>
<a name="l00045"></a>00045 <span class="comment">/*  #define TEST if you want some printout */</span>
<a name="l00046"></a>00046 <span class="comment">/* #define TEST */</span>
<a name="l00047"></a>00047 <span class="preprocessor">#ifndef FALSE</span>
<a name="l00048"></a>00048 <span class="preprocessor"></span><span class="preprocessor">#define FALSE 0</span>
<a name="l00049"></a>00049 <span class="preprocessor"></span><span class="preprocessor">#define TRUE 1</span>
<a name="l00050"></a>00050 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00051"></a>00051 <span class="preprocessor"></span>
<a name="l00052"></a>00052 
<a name="l00053"></a>00053 <span class="preprocessor">#ifdef MAIN</span>
<a name="l00054"></a>00054 <span class="preprocessor"></span><span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00055"></a>00055 <span class="preprocessor">#include &lt;memory.h&gt;</span>
<a name="l00056"></a>00056 
<a name="l00057"></a>00057 <span class="comment">/* example of how to define a table in rom or flash */</span>
<a name="l00058"></a>00058 
<a name="l00059"></a>00059 <span class="keyword">const</span> <span class="keyword">struct </span>table_3x3_16 table1 = 
<a name="l00060"></a>00060 {
<a name="l00061"></a>00061         .rows = 3,
<a name="l00062"></a>00062         .cols = 3,
<a name="l00063"></a>00063         .variable_axis = FALSE,  <span class="comment">/* default is zero anyway */</span>
<a name="l00064"></a>00064         .byte_table = FALSE,     <span class="comment">/* default is zero anyway */</span>
<a name="l00065"></a>00065         .min_x = 0,
<a name="l00066"></a>00066         .max_x = 1000,
<a name="l00067"></a>00067         .min_y = 0,
<a name="l00068"></a>00068         .max_y = 100,
<a name="l00069"></a>00069         <span class="comment">/* data, a full row on each line: */</span>
<a name="l00070"></a>00070         .data = { 
<a name="l00071"></a>00071                 { 1, 2, 3 }, 
<a name="l00072"></a>00072                 { 4, 5, 6 }, 
<a name="l00073"></a>00073                 { 7, 8, 9 } }
<a name="l00074"></a>00074 };      
<a name="l00075"></a>00075 
<a name="l00076"></a>00076 <span class="keywordtype">int</span>
<a name="l00077"></a>00077 main ()
<a name="l00078"></a>00078 {
<a name="l00079"></a>00079         <span class="comment">/* Example of use */</span>
<a name="l00080"></a>00080         int32_t j;
<a name="l00081"></a>00081 
<a name="l00082"></a>00082         printf(<span class="stringliteral">&quot;\n %d %d %d \n %d %d %d \n %d %d %d\n&quot;</span>,
<a name="l00083"></a>00083         table1.data[0][0], table1.data[0][1], table1.data[0][2],
<a name="l00084"></a>00084         table1.data[1][0], table1.data[1][1], table1.data[1][2],
<a name="l00085"></a>00085         table1.data[2][0], table1.data[2][1], table1.data[2][2]
<a name="l00086"></a>00086         );
<a name="l00087"></a>00087 
<a name="l00088"></a>00088         fflush(stdout);
<a name="l00089"></a>00089 
<a name="l00090"></a>00090         printf(<span class="stringliteral">&quot;x axis ranges from %d to %d\n&quot;</span>,table1.min_x, table1.max_x);
<a name="l00091"></a>00091         printf(<span class="stringliteral">&quot;y axis ranges from %d to %d\n&quot;</span>,table1.min_y, table1.max_y);
<a name="l00092"></a>00092         printf(<span class="stringliteral">&quot;note: the origin is the upper left\n&quot;</span>);
<a name="l00093"></a>00093 
<a name="l00094"></a>00094         <span class="comment">/*  for (i = 0; i &lt; 100000000; ++i)  // for speed test */</span>
<a name="l00095"></a>00095         j = table_lookup_jz (495,45, (<span class="keyword">struct</span> table_jz *)&amp;table1);
<a name="l00096"></a>00096         printf (<span class="stringliteral">&quot;f(x,y) = %d\n&quot;</span>, j);
<a name="l00097"></a>00097 
<a name="l00098"></a>00098 <span class="preprocessor">#if 0</span>
<a name="l00099"></a>00099 <span class="preprocessor"></span><span class="preprocessor">#ifdef TEST</span>
<a name="l00100"></a>00100 <span class="preprocessor"></span>        i = table_lookup_jz (460, 460, &amp;table);
<a name="l00101"></a>00101         printf (<span class="stringliteral">&quot;f(x,y) = %d\n&quot;</span>, i);
<a name="l00102"></a>00102         i = table_lookup_jz (1000, 1000, &amp;table);
<a name="l00103"></a>00103         printf (<span class="stringliteral">&quot;f(x,y) = %d\n&quot;</span>, i);
<a name="l00104"></a>00104         i = table_lookup_jz (0, 0, &amp;table);
<a name="l00105"></a>00105         printf (<span class="stringliteral">&quot;f(x,y) = %d\n&quot;</span>, i);
<a name="l00106"></a>00106         i = table_lookup_jz (500, 500, &amp;table);
<a name="l00107"></a>00107         printf (<span class="stringliteral">&quot;f(x,y) = %d\n&quot;</span>, i);
<a name="l00108"></a>00108         i = table_lookup_jz (0, 1000, &amp;table);
<a name="l00109"></a>00109         printf (<span class="stringliteral">&quot;f(x,y) = %d\n&quot;</span>, i);
<a name="l00110"></a>00110         i = table_lookup_jz (1000, 0, &amp;table);
<a name="l00111"></a>00111         printf (<span class="stringliteral">&quot;f(x,y) = %d\n&quot;</span>, i);
<a name="l00112"></a>00112         i = table_lookup_jz (2000, 2000, &amp;table);
<a name="l00113"></a>00113         printf (<span class="stringliteral">&quot;f(x,y) = %d\n&quot;</span>, i);
<a name="l00114"></a>00114         i = table_lookup_jz (1000, -5, &amp;table);
<a name="l00115"></a>00115         printf (<span class="stringliteral">&quot;f(x,y) = %d\n&quot;</span>, i);
<a name="l00116"></a>00116 <span class="preprocessor">#endif</span>
<a name="l00117"></a>00117 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00118"></a>00118 <span class="preprocessor"></span>
<a name="l00119"></a>00119         <span class="keywordflow">return</span> 1;
<a name="l00120"></a>00120 }                               <span class="comment">/* main() */</span>
<a name="l00121"></a>00121 <span class="preprocessor">#endif</span>
<a name="l00122"></a>00122 <span class="preprocessor"></span>
<a name="l00123"></a>00123 
<a name="l00124"></a>00124 <span class="comment">/* given a value, n and a sorted array of n int16_t elements, return the index to the entry that is less than or equal to value */</span>
<a name="l00125"></a>00125 
<a name="l00126"></a>00126 <span class="keyword">inline</span> uint_fast16_t
<a name="l00127"></a>00127 lsearch_jz (<span class="keyword">register</span> <span class="keyword">const</span> int_fast16_t value, <span class="keyword">const</span> int16_t * array, uint_fast16_t n)
<a name="l00128"></a>00128 {
<a name="l00129"></a>00129         <span class="keyword">register</span> int16_t *ptr = (int16_t *) array + --n;        <span class="comment">/* move to last position in array */</span>
<a name="l00130"></a>00130 
<a name="l00131"></a>00131 <span class="preprocessor">#ifdef TEST</span>
<a name="l00132"></a>00132 <span class="preprocessor"></span>        printf (<span class="stringliteral">&quot;bsearch %d %d %d for %d\n&quot;</span>, array[0], array[1], array[2], value);
<a name="l00133"></a>00133 <span class="preprocessor">#endif</span>
<a name="l00134"></a>00134 <span class="preprocessor"></span>
<a name="l00135"></a>00135         <span class="comment">/* out of bounds checks */</span>
<a name="l00136"></a>00136         <span class="keywordflow">if</span> (value &lt;= *array)
<a name="l00137"></a>00137         <span class="keywordflow">return</span> 0;
<a name="l00138"></a>00138 
<a name="l00139"></a>00139         <span class="comment">/* check for too big */</span>
<a name="l00140"></a>00140         <span class="keywordflow">if</span> (value &gt;= *ptr)
<a name="l00141"></a>00141         <span class="keywordflow">return</span> n;
<a name="l00142"></a>00142 
<a name="l00143"></a>00143         <span class="keywordflow">while</span> (*ptr &gt; value)
<a name="l00144"></a>00144         --ptr;                  <span class="comment">/* loop from large to small */</span>
<a name="l00145"></a>00145 
<a name="l00146"></a>00146         <span class="keywordflow">return</span> (uint_fast16_t) (ptr - array);
<a name="l00147"></a>00147 }
<a name="l00148"></a>00148 
<a name="l00149"></a>00149 <span class="comment">/* generic binary search for a int16_t array */</span>
<a name="l00150"></a>00150 
<a name="l00151"></a>00151 <span class="keyword">inline</span> uint_fast16_t
<a name="l00152"></a>00152 bsearch_jz (<span class="keyword">register</span> <span class="keyword">const</span> int_fast16_t value, <span class="keyword">const</span> int16_t * array, uint_fast16_t n)
<a name="l00153"></a>00153 {
<a name="l00154"></a>00154         <span class="keyword">register</span> uint_fast16_t lower;
<a name="l00155"></a>00155         <span class="keyword">register</span> uint_fast16_t middle;
<a name="l00156"></a>00156         <span class="keyword">register</span> uint_fast16_t upper;
<a name="l00157"></a>00157 
<a name="l00158"></a>00158 <span class="preprocessor">#ifdef TEST</span>
<a name="l00159"></a>00159 <span class="preprocessor"></span>        printf (<span class="stringliteral">&quot;bsearch %d %d %d for %d\n&quot;</span>, array[0], array[1], array[2], value);
<a name="l00160"></a>00160 <span class="preprocessor">#endif</span>
<a name="l00161"></a>00161 <span class="preprocessor"></span>
<a name="l00162"></a>00162         <span class="comment">/* out of bounds checks */</span>
<a name="l00163"></a>00163         <span class="keywordflow">if</span> (value &lt;= *array)            <span class="comment">/* too low */</span>
<a name="l00164"></a>00164         <span class="keywordflow">return</span> 0;
<a name="l00165"></a>00165 
<a name="l00166"></a>00166         upper = --n;                    <span class="comment">/* note, n is now max index */</span>
<a name="l00167"></a>00167         <span class="keywordflow">if</span> (value &gt;= array[upper])      <span class="comment">/* too high */</span>
<a name="l00168"></a>00168         <span class="keywordflow">return</span> n;
<a name="l00169"></a>00169 
<a name="l00170"></a>00170         lower = 0;
<a name="l00171"></a>00171 
<a name="l00172"></a>00172         <span class="keywordflow">for</span> (;;)
<a name="l00173"></a>00173         {
<a name="l00174"></a>00174                 middle = (upper - lower) &gt;&gt; 1;  <span class="comment">/* 1/2 way between them */</span>
<a name="l00175"></a>00175 
<a name="l00176"></a>00176                 <span class="keywordflow">if</span> (middle == lower)
<a name="l00177"></a>00177                 <span class="keywordflow">return</span> lower;           <span class="comment">/* done */</span>
<a name="l00178"></a>00178 
<a name="l00179"></a>00179                 <span class="keywordflow">if</span> (array[middle] &lt; value)
<a name="l00180"></a>00180                 lower = middle;
<a name="l00181"></a>00181                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (array[middle] &gt; value)
<a name="l00182"></a>00182                 upper = middle;
<a name="l00183"></a>00183                 <span class="keywordflow">else</span>                    <span class="comment">/* equal */</span>
<a name="l00184"></a>00184                 <span class="keywordflow">return</span> middle;
<a name="l00185"></a>00185         }
<a name="l00186"></a>00186         <span class="keywordflow">return</span> 0;                       <span class="comment">/* never get here */</span>
<a name="l00187"></a>00187 }
<a name="l00188"></a>00188 
<a name="l00189"></a>00189 <span class="preprocessor">#ifdef BSEARCH_TEST</span>
<a name="l00190"></a>00190 <span class="preprocessor"></span>
<a name="l00191"></a>00191 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00192"></a>00192 
<a name="l00193"></a>00193 <span class="keywordtype">int</span>
<a name="l00194"></a>00194 main ()
<a name="l00195"></a>00195 {
<a name="l00196"></a>00196         int16_t array[6] = { 1, 5, 10, 15, 20, 29 };
<a name="l00197"></a>00197 
<a name="l00198"></a>00198         printf (<span class="stringliteral">&quot;array = 1, 5, 10, 15, 20, 29\n&quot;</span>);
<a name="l00199"></a>00199         printf (<span class="stringliteral">&quot;6 = %d\n&quot;</span>, bsearch (6, array, 6));
<a name="l00200"></a>00200         printf (<span class="stringliteral">&quot;0 = %d\n&quot;</span>, bsearch (0, array, 6));
<a name="l00201"></a>00201         printf (<span class="stringliteral">&quot;30 = %d\n&quot;</span>, bsearch (30, array, 6));
<a name="l00202"></a>00202         printf (<span class="stringliteral">&quot;1 = %d\n&quot;</span>, bsearch (1, array, 6));
<a name="l00203"></a>00203         printf (<span class="stringliteral">&quot;20 = %d\n&quot;</span>, bsearch (20, array, 6));
<a name="l00204"></a>00204         printf (<span class="stringliteral">&quot;17 = %d\n&quot;</span>, bsearch (17, array, 6));
<a name="l00205"></a>00205 
<a name="l00206"></a>00206         <span class="keywordflow">return</span> 0;
<a name="l00207"></a>00207 }
<a name="l00208"></a>00208 
<a name="l00209"></a>00209 <span class="preprocessor">#endif</span>
<a name="l00210"></a>00210 <span class="preprocessor"></span><span class="comment">/* Given a fraction, find value between two values */</span>
<a name="l00211"></a>00211 
<a name="l00212"></a>00212 <span class="keyword">inline</span> <span class="keyword">static</span> int_fast16_t
<a name="l00213"></a>00213 interpolate (<span class="keyword">const</span> int_fast16_t fraction, <span class="keyword">const</span> int_fast16_t value1, <span class="keyword">const</span> int_fast16_t value2)
<a name="l00214"></a>00214 <span class="comment">/* Note: fraction is bin 8 and ranges 0 to 1 */</span>
<a name="l00215"></a>00215 {
<a name="l00216"></a>00216 <span class="preprocessor">#ifdef TEST</span>
<a name="l00217"></a>00217 <span class="preprocessor"></span>        printf (<span class="stringliteral">&quot;interpolate %f between %d and %d\n&quot;</span>, fraction / 256., value1, value2);
<a name="l00218"></a>00218 <span class="preprocessor">#endif</span>
<a name="l00219"></a>00219 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (value1 == value2 || fraction == 0)  <span class="comment">/* for speed */</span>
<a name="l00220"></a>00220         <span class="keywordflow">return</span> value1;
<a name="l00221"></a>00221 
<a name="l00222"></a>00222         <span class="keywordflow">if</span> (value1 &lt; value2)            <span class="comment">/* postitive slope */</span>
<a name="l00223"></a>00223         <span class="keywordflow">return</span> value1 + (((value2 - value1) * (int32_t) fraction) &gt;&gt; 8);        <span class="comment">/* correct back to bin 0  */</span>
<a name="l00224"></a>00224         else
<a name="l00225"></a>00225         return value1 - (((value1 - value2) * (int32_t) fraction) &gt;&gt; 8);        <span class="comment">/* correct back to bin 0  */</span>
<a name="l00226"></a>00226 }
<a name="l00227"></a>00227 
<a name="l00228"></a>00228 <span class="comment">/*  macro to extract value from table - could be u8 or s16 */</span>
<a name="l00229"></a>00229 <span class="preprocessor">#define value(index)   (table-&gt;byte_table !=0 ? (int16_t)(*(uint8_t *)(index)) : (*(int16_t *)(index)))</span>
<a name="l00230"></a>00230 <span class="preprocessor"></span>
<a name="l00231"></a>00231 <span class="comment">/************************************************************************</span>
<a name="l00232"></a>00232 <span class="comment"></span>
<a name="l00233"></a>00233 <span class="comment">@param x value</span>
<a name="l00234"></a>00234 <span class="comment">@param y value (optional)</span>
<a name="l00235"></a>00235 <span class="comment">@param pointer to table structure</span>
<a name="l00236"></a>00236 <span class="comment">@return lookup value from table</span>
<a name="l00237"></a>00237 <span class="comment"></span>
<a name="l00238"></a>00238 <span class="comment">************************************************************************/</span>
<a name="l00239"></a>00239 int16_t
<a name="l00240"></a>00240 table_lookup_jz (<span class="keyword">const</span> int32_t x, <span class="keyword">const</span> int32_t y, <span class="keyword">const</span> <span class="keyword">struct</span> table_jz * table)
<a name="l00241"></a>00241 {
<a name="l00242"></a>00242         <span class="keyword">register</span> uint32_t xbin;         <span class="comment">/* bin 8, the x value converted to an index with fraction */</span>
<a name="l00243"></a>00243         <span class="keyword">register</span> uint32_t ybin;         <span class="comment">/* bin 8, the y value converted to an index with fraction */</span>
<a name="l00244"></a>00244         <span class="keyword">register</span> uint_fast16_t x_index; <span class="comment">/* bin 0 index version of xbin */</span>
<a name="l00245"></a>00245         <span class="keyword">register</span> uint_fast16_t y_index; <span class="comment">/* bin 0 index */</span>
<a name="l00246"></a>00246         <span class="keyword">register</span> uint8_t *ptr;          <span class="comment">/* this pointer actually points to uint8s or int16s */</span>
<a name="l00247"></a>00247         <span class="keyword">register</span> int32_t value1;
<a name="l00248"></a>00248         <span class="keyword">register</span> uint_fast8_t entry_size;     <span class="comment">/* 8 bit or 16 bit lookup */</span>
<a name="l00249"></a>00249 
<a name="l00250"></a>00250         entry_size = table-&gt;byte_table != 0 ? 0 : 1;  <span class="comment">/* 0 = 8 bit, 1 = 16 bit, later used as 2**entry_table */</span>
<a name="l00251"></a>00251 
<a name="l00252"></a>00252 <span class="preprocessor">#ifdef TEST</span>
<a name="l00253"></a>00253 <span class="preprocessor"></span>        printf (<span class="stringliteral">&quot;\ntable lookup of %d, %d\n&quot;</span>, x, y);
<a name="l00254"></a>00254 <span class="preprocessor">#endif</span>
<a name="l00255"></a>00255 <span class="preprocessor"></span>
<a name="l00256"></a>00256         <span class="keywordflow">if</span> (table == 0 || table-&gt;rows &lt; 1 || table-&gt;cols &lt; 2)
<a name="l00257"></a>00257         {                               <span class="comment">/* error check */</span>
<a name="l00258"></a>00258                 system_error(3879, __FILE__, __LINE__, <span class="stringliteral">&quot;&quot;</span>);
<a name="l00259"></a>00259                 <span class="keywordflow">return</span> 0;
<a name="l00260"></a>00260         }
<a name="l00261"></a>00261 
<a name="l00262"></a>00262         <span class="comment">/* find fractional indexes that point into the table */</span>
<a name="l00263"></a>00263 
<a name="l00264"></a>00264         <span class="keywordflow">if</span> (table-&gt;variable_axis == 0)  <span class="comment">/* use fixed axis increment method */</span>
<a name="l00265"></a>00265         {
<a name="l00266"></a>00266                 <span class="comment">/* calc x index by offsetting and scaling */</span>
<a name="l00267"></a>00267                 <span class="keywordflow">if</span> (x &lt;= table-&gt;min_x)  <span class="comment">/* less than min  */</span>
<a name="l00268"></a>00268                 x_index = xbin = 0;
<a name="l00269"></a>00269                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (x &gt;= table-&gt;max_x)
<a name="l00270"></a>00270                 {                       <span class="comment">/* greater than max */</span>
<a name="l00271"></a>00271                         x_index = (table-&gt;cols - 1);
<a name="l00272"></a>00272                         xbin = 0;
<a name="l00273"></a>00273                 }
<a name="l00274"></a>00274                 <span class="keywordflow">else</span>
<a name="l00275"></a>00275                 {                       <span class="comment">/* in the middle, calc how far */</span>
<a name="l00276"></a>00276                         xbin = ((table-&gt;cols - 1) * (x - table-&gt;min_x) &lt;&lt; 8) / (table-&gt;max_x - table-&gt;min_x);   <span class="comment">/* result is bin 8 */</span>
<a name="l00277"></a>00277                         x_index = (xbin &gt;&gt; 8);  <span class="comment">/* convert factional index to integer index */</span>
<a name="l00278"></a>00278                         xbin &amp;= 0xff;
<a name="l00279"></a>00279                 }
<a name="l00280"></a>00280 
<a name="l00281"></a>00281                 <span class="comment">/* calc y index by offsetting and scaling */</span>
<a name="l00282"></a>00282                 <span class="keywordflow">if</span> (table-&gt;rows == 1 || y &lt;= table-&gt;min_y)
<a name="l00283"></a>00283                 {
<a name="l00284"></a>00284                         y_index = ybin = 0;
<a name="l00285"></a>00285                         ptr = (uint8_t *)table-&gt;data + (x_index &lt;&lt; entry_size);
<a name="l00286"></a>00286                 }
<a name="l00287"></a>00287                 <span class="keywordflow">else</span>
<a name="l00288"></a>00288                 {       <span class="comment">/* find y position in table  */</span>
<a name="l00289"></a>00289                         <span class="keywordflow">if</span> (y &gt;= table-&gt;max_y)
<a name="l00290"></a>00290                         {
<a name="l00291"></a>00291                                 y_index = (table-&gt;rows - 1);
<a name="l00292"></a>00292                                 ybin = 0;
<a name="l00293"></a>00293                         }
<a name="l00294"></a>00294                         <span class="keywordflow">else</span>
<a name="l00295"></a>00295                         {                       <span class="comment">/* in the middle */</span>
<a name="l00296"></a>00296                                 ybin = ((table-&gt;rows - 1) * (y - table-&gt;min_y) &lt;&lt; 8) / (table-&gt;max_y - table-&gt;min_y);   <span class="comment">/* result is bin 8 */</span>
<a name="l00297"></a>00297                                 y_index = (ybin &gt;&gt; 8);
<a name="l00298"></a>00298                                 y_index &amp;= 0xff;
<a name="l00299"></a>00299                         }
<a name="l00300"></a>00300                         ptr = (uint8_t *)table-&gt;data + (((table-&gt;cols * y_index) + x_index) &lt;&lt; entry_size);
<a name="l00301"></a>00301                 }
<a name="l00302"></a>00302         }
<a name="l00303"></a>00303         <span class="keywordflow">else</span>   <span class="comment">/* variable axis */</span>
<a name="l00304"></a>00304         {
<a name="l00305"></a>00305                 <span class="comment">/* find fractional indexes using variable axis increments method */</span>
<a name="l00306"></a>00306                 x_index = bsearch_jz(x, table-&gt;x_axis, table-&gt;cols);
<a name="l00307"></a>00307 
<a name="l00308"></a>00308                 xbin = ((x - table-&gt;x_axis[x_index]) &lt;&lt; 8) / (table-&gt;x_axis[x_index + 1] - table-&gt;x_axis[x_index]);     <span class="comment">/* bin 8 result */</span>
<a name="l00309"></a>00309 
<a name="l00310"></a>00310                 <span class="comment">/* do y axis if this is a 2D lookup */</span>
<a name="l00311"></a>00311 
<a name="l00312"></a>00312                 <span class="keywordflow">if</span> (table-&gt;rows == 1 || y &lt;= table-&gt;min_y)   <span class="comment">/* 1D or outside of table */</span>
<a name="l00313"></a>00313                 {
<a name="l00314"></a>00314                         y_index = ybin = 0;
<a name="l00315"></a>00315                         ptr = (uint8_t *)table-&gt;data + (x_index &lt;&lt; entry_size);
<a name="l00316"></a>00316                 }
<a name="l00317"></a>00317                 <span class="keywordflow">else</span>
<a name="l00318"></a>00318                 {       <span class="comment">/* find y position in table */</span>
<a name="l00319"></a>00319                         y_index = bsearch_jz(y, table-&gt;y_axis, table-&gt;rows);
<a name="l00320"></a>00320                         ybin = ((y - table-&gt;y_axis[y_index]) &lt;&lt; 8) / (table-&gt;y_axis[y_index + 1] - table-&gt;y_axis[y_index]);
<a name="l00321"></a>00321                         ptr = (uint8_t *)table-&gt;data + (((table-&gt;cols * y_index) + x_index) &lt;&lt; entry_size);
<a name="l00322"></a>00322                 }
<a name="l00323"></a>00323         }
<a name="l00324"></a>00324 
<a name="l00325"></a>00325         <span class="comment">/* now interpolate from current point to next point for accuracy */</span>
<a name="l00326"></a>00326 
<a name="l00327"></a>00327 <span class="preprocessor">#ifdef TEST</span>
<a name="l00328"></a>00328 <span class="preprocessor"></span>        printf (<span class="stringliteral">&quot;variable axis  = %d\n&quot;</span>, table-&gt;variable_axis);
<a name="l00329"></a>00329         printf (<span class="stringliteral">&quot;x index = %f\n&quot;</span>, x_index + xbin / 256.0);
<a name="l00330"></a>00330         printf (<span class="stringliteral">&quot;y index  = %f\n&quot;</span>, y_index + ybin / 256.0);
<a name="l00331"></a>00331         printf (<span class="stringliteral">&quot;data[xindex][yindex] = %d\n&quot;</span>,value(ptr));
<a name="l00332"></a>00332 <span class="preprocessor">#endif</span>
<a name="l00333"></a>00333 <span class="preprocessor"></span>
<a name="l00334"></a>00334         <span class="comment">/* interpolate using the factional distance between points  */</span>
<a name="l00335"></a>00335         <span class="keywordflow">if</span> (x_index + 1 &gt;= table-&gt;cols) <span class="comment">/* out of bounds on x-axis */</span>
<a name="l00336"></a>00336            value1 = value(ptr);         <span class="comment">/* use last point in table */</span>
<a name="l00337"></a>00337         <span class="keywordflow">else</span>
<a name="l00338"></a>00338            value1 = interpolate ((int_fast16_t)xbin, value(ptr), value(ptr + (1&lt;&lt;entry_size)));
<a name="l00339"></a>00339 
<a name="l00340"></a>00340         <span class="keywordflow">if</span> (table-&gt;rows == 1)           <span class="comment">/* 1D lookup, we are done */</span>
<a name="l00341"></a>00341            <span class="keywordflow">return</span> value1;
<a name="l00342"></a>00342 
<a name="l00343"></a>00343         <span class="keywordflow">if</span> (y_index + 1 &gt;= table-&gt;rows || ybin == 0)    <span class="comment">/* out of bounds (unusual case) */</span>
<a name="l00344"></a>00344            <span class="keywordflow">return</span> value1;
<a name="l00345"></a>00345 
<a name="l00346"></a>00346         {
<a name="l00347"></a>00347                 <span class="comment">/* interpolate using x values from the next row */</span>
<a name="l00348"></a>00348                 <span class="keyword">register</span> int32_t value2;
<a name="l00349"></a>00349 
<a name="l00350"></a>00350                 <span class="keywordflow">if</span> (x_index + 1 &gt;= table-&gt;cols) <span class="comment">/* out of bounds on x-axis */</span>
<a name="l00351"></a>00351                    value2 = value(ptr + (table-&gt;cols &lt;&lt; entry_size));
<a name="l00352"></a>00352                 <span class="keywordflow">else</span>
<a name="l00353"></a>00353                    value2 = interpolate ((int_fast16_t)xbin, value(ptr + (table-&gt;cols &lt;&lt; entry_size)), value(ptr + ((table-&gt;cols + 1) &lt;&lt; entry_size)));
<a name="l00354"></a>00354 
<a name="l00355"></a>00355 <span class="preprocessor">#ifdef TEST</span>
<a name="l00356"></a>00356 <span class="preprocessor"></span>                printf (<span class="stringliteral">&quot;after x interpolations, got %d and %d\n&quot;</span>, value1, value2);
<a name="l00357"></a>00357 <span class="preprocessor">#endif</span>
<a name="l00358"></a>00358 <span class="preprocessor"></span>
<a name="l00359"></a>00359                 <span class="comment">/* interpolate between 2 values */</span>
<a name="l00360"></a>00360                 <span class="keywordflow">return</span> interpolate ((int_fast16_t)ybin, value1, value2);
<a name="l00361"></a>00361         }   
<a name="l00362"></a>00362 } <span class="comment">/* table_lookup_jz() */</span>
</pre></div></div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address style="text-align: right;"><small>Generated on Mon Nov 14 12:33:03 2011 for O5E by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
